<!DOCTYPE html>
<!--
Copyright (c) 2016 gam0022
Released under the MIT license
http://opensource.org/licenses/mit-license.php
-->
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>three.js webgl - raytracing - ruby</title>
		<style type="text/css">
			body {
				background-color: black;
				margin: 0;
				padding: 0;
			}

			a { color: skyblue }

			canvas {
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
				margin: auto;
			}

			#info {
				color: white;
				font-size: 13px;
				position: absolute;
				bottom: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl raymarching example -
			reflect by <a href="https://github.com/gam0022" target="_blank">gam0022</a> (<a href="http://qiita.com/gam0022/items/03699a07e4a4b5f2d41f" target="_blank">article in Japanese</a>)
		</div>

		<script id="fragment_shader" type="x-shader/x-fragment">

			precision highp float;

			uniform vec2 resolution;
			uniform vec3 cameraPos;
			uniform vec3 cameraDir;

			const float EPS = 0.01;
			const float OFFSET = EPS * 100.0;
			const vec3 lightDir = vec3( -0.48666426339228763, -0.3244428422615251, 0.8111071056538127 );


			float det( vec3 a, vec3 b, vec3 c ) {
				return (a.x * b.y * c.z)
						+ (a.y * b.z * c.x)
						+ (a.z * b.x * c.y)
						- (a.x * b.z * c.y)
						- (a.y * b.x * c.z)
						- (a.z * b.y * c.x);
			}

			struct intersect {
				bool hit;
				bool front;
				vec3 position;
				float distance;
				vec3 normal;
				vec3 color;
			};

			intersect rayIntersectsTriangle( vec3 origin, vec3 ray, vec3 v0, vec3 v1, vec3 v2 ) {
			    // 交差判定結果を

				intersect ret;
				ret.hit = false;
				ret.distance = 0.0;
			
			    // レイの逆方向のベクトルを得る
			    //var invRay = ray.clone().multiplyScalar(-1);
			    //var edge1 = (new THREE.Vector3()).subVectors(v1, v0);
			    //var edge2 = (new THREE.Vector3()).subVectors(v2, v0);

				vec3 invRay = - ray;
				vec3 edge1 = v1 - v0;
				vec3 edge2 = v2 - v0;
			
			    // クラメルの公式の分母
			    float denominator = det( edge1, edge2, invRay );
			
			    // レイが平面と平行でないかチェック
			    if ( denominator <= 0.0 ) {
			        return ret;
			    }
			
			    vec3 d = origin - v0;
			
			    float u = det(d, edge2, invRay) / denominator;
			    if ((u >= 0.0 ) && (u <= 1.0 )) {
			        float v = det(edge1, d, invRay) / denominator;
			        if ((v >= 0.0 ) && (u + v <= 1.0 )) {
			            float t = det(edge1, edge2, d) / denominator;
			
			            // 距離がマイナスの場合は交差していない
			            if ( t < 0.0 ) {
			                return ret;
			            }
			
			            // var tmp = ray.clone().multiplyScalar(t);
			            // ret.point = (new THREE.Vector3()).addVectors(origin, tmp);
			            ret.hit = true;
						ret.position = origin + ray * t;
			            ret.distance = t;
						ret.normal = normalize( cross( edge1, edge2 ) );
			        }
			    }
			
			    return ret;
			}

			float checkeredPattern( vec3 p ) {

				float u = 1.0 - floor( mod( p.x, 2.0 ) );
				float v = 1.0 - floor( mod( p.z, 2.0 ) );

				if ( ( u == 1.0 && v < 1.0 ) || ( u < 1.0 && v == 1.0 ) ) {

					return 0.2;

				} else {

					return 1.0;

				}

			}

			intersect rayIntersectsTriangleDoubleSide( vec3 origin, vec3 ray, vec3 v0, vec3 v1, vec3 v2 ) {
				intersect front = rayIntersectsTriangle( origin, ray, v0, v1, v2 );
				front.front = true;

				intersect back  = rayIntersectsTriangle( origin, ray, v0, v2, v1 );
				back.front = false;

				if ( front.hit ) return front; else return back;
			}

			vec3 hsv2rgb( vec3 c ) {

				vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );
				vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );
				return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );

			}

			intersect getRayColor( vec3 origin, vec3 ray) {

				intersect nearest, tmp;
				nearest.hit = false;
				nearest.distance = 100000.0;

				//DIAMOND_GEOMETRY

				if ( nearest.hit ) {

					float diffuse1 = clamp( dot( lightDir, nearest.normal ), 0.1, 1.0 );
					float diffuse2 = clamp( dot( -lightDir, nearest.normal ), 0.1, 1.0 );
					//float specular1 = pow( clamp( dot( reflect( lightDir, nearest.normal ), ray ), 0.0, 1.0 ), 10.0 );
					//float specular2 = pow( clamp( dot( reflect( -lightDir, nearest.normal ), ray ), 0.0, 1.0 ), 10.0 );
					nearest.color = vec3( 0.6, 0.1, 0.1 ).rgb * ( diffuse1 + diffuse2/* + specular1 + specular2*/ );

				} else {

					nearest.color = vec3( 0.0 );

				}

				return nearest;// - pow( clamp( 0.05 * depth, 0.0, 0.6 ), 2.0 );

			}

			void main(void) {

				// fragment position
				vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y );

				// camera and ray
				vec3 cPos  = cameraPos;
				vec3 cDir  = cameraDir;
				vec3 cSide = normalize( cross( cDir, vec3( 0.0, 1.0 ,0.0 ) ) );
				vec3 cUp   = normalize( cross( cSide, cDir ) );
				float targetDepth = 1.3;
				vec3 ray = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth );

				vec3 color = vec3( 0.0 );
				intersect nearest;
				float alpha = 1.0;

				for ( int i = 0; i < 6; i++ ) {

					float eta = 1.5;
					nearest = getRayColor( cPos, ray );
					color += alpha * nearest.color;

					alpha *= 0.8;
					if ( nearest.front ) eta = 1.0 / eta;
					ray = normalize( refract( ray, nearest.normal, eta ) );
					cPos = nearest.position + nearest.normal * OFFSET;

					if ( !nearest.hit ) break;

				}

				gl_FragColor = vec4(color, 1.0);

			}

		</script>

		<script id="vertex_shader" type="x-shader/x-vertex">

			attribute vec3 position;

			void main(void) {

				gl_Position = vec4(position, 1.0);

			}

		</script>

		<script src="js/three.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>

			var camera, dummyCamera, scene, controls, renderer;
			var geometry, material, mesh;
			var mouse = new THREE.Vector2( 0.5, 0.5 );
			var canvas;
			var stats;

			var clock = new THREE.Clock();

			var config = {
				saveImage: function() {

					renderer.render( scene, dummyCamera );
					window.open( canvas.toDataURL() );

				},
				freeCamera: true,
				resolution: '512',
			};

			init();

			function init() {

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(35, 800/600);//new THREE.Camera();
				dummyCamera = new THREE.Camera();
				camera.position.set( 0.0, 0.0, 2.5 );
				camera.lookAt( new THREE.Vector3( 0.0, 0.0, 0.0 ) );

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

				var onError = function ( xhr ) {
				};

				var loader = new THREE.OBJLoader( manager );
				loader.load( 'models/a03.obj', function ( object ) {

					var bufferGeometry = object.children[0].geometry;
					var diamondGeometry = new THREE.Geometry().fromBufferGeometry( bufferGeometry );
					console.log( diamondGeometry );

					var diamondGeometryGlsl = "";

					var faces = diamondGeometry.faces;
					var vertices = diamondGeometry.vertices;
					var n = faces.length;
					console.log("n: " + n);
					for(var i = 0; i < n; i++ ) {
						var face = faces[ i ];
						var a = vertices[ face.a ];
						var b = vertices[ face.c ];
						var c = vertices[ face.b ];

						a.z = -a.z;
						b.z = -b.z;
						c.z = -c.z;
						diamondGeometryGlsl += [
							'tmp = rayIntersectsTriangleDoubleSide( origin, ray, vec3( ' + a.x + ', ' + a.y + ', ' + a.z + ' ), vec3( ' + b.x + ', ' + b.y + ', ' + b.z + ' ), vec3( ' + c.x + ', ' + c.y + ', ' + c.z + ' ) );',
							'if ( tmp.hit && tmp.distance < nearest.distance ) nearest = tmp;',
						].join("\n");
					}

					geometry = new THREE.PlaneBufferGeometry( 2.0, 2.0 );
					material = new THREE.RawShaderMaterial( {
						uniforms: {
							resolution: { type: 'v2', value: new THREE.Vector2( 512, 512 ) },
							cameraPos: { type: 'v3', value: camera.getWorldPosition() },
							cameraDir: { type: 'v3', value: camera.getWorldDirection() },
						},
						vertexShader: document.getElementById( 'vertex_shader' ).textContent,
						fragmentShader: document.getElementById( 'fragment_shader' ).textContent.replace( '//DIAMOND_GEOMETRY', diamondGeometryGlsl )
					} );
					mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );

					renderer = new THREE.WebGLRenderer();
					//renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( 512, 512 );

					canvas = renderer.domElement;
					canvas.addEventListener( 'mousemove', onMouseMove );
					window.addEventListener( 'resize', onWindowResize );
					document.body.appendChild( canvas );

					controls = new THREE.OrbitControls( camera, canvas );

					controls.enableDamping = true;
					controls.dampingFactor = 0.25;
					controls.enableZoom = false;

					var gui = new dat.GUI();
					gui.add( config, 'saveImage' ).name( 'Save Image' );
					gui.add( config, 'freeCamera' ).name( 'Free Camera' );
					gui.add( config, 'resolution', [ '256', '512', '800', 'full' ] ).name( 'Resolution' ).onChange( function( value ) {

						if ( value !== 'full' ) {

							canvas.width = value;
							canvas.height = value;

						}
						onWindowResize();

					} );

					stats = new Stats();
					document.body.appendChild( stats.domElement );

					render();


				}, onProgress, onError );

			}

			function render( timestamp ) {

				var delta = clock.getDelta();

				stats.begin();

				if ( config.freeCamera ) {

					controls.update( delta );

				} else {

					camera.position.set( mouse.x - 0.5, mouse.y * 4, -20 );
					camera.lookAt( new THREE.Vector3( 0.0, -0.0, 1.0 ).add( camera.position ) );

				}

				material.uniforms.resolution.value = new THREE.Vector2( canvas.width, canvas.height );
				material.uniforms.cameraPos.value = camera.getWorldPosition();
				material.uniforms.cameraDir.value = camera.getWorldDirection();
				renderer.render( scene, dummyCamera );

				stats.end();
				requestAnimationFrame( render );

			}

			function onMouseMove( e ) {

				mouse.x = e.offsetX / canvas.width;
				mouse.y = e.offsetY / canvas.height;

			}

			function onWindowResize( e ) {

				if ( config.resolution === 'full' ) {

					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;

				}

				renderer.setSize( canvas.width, canvas.height );

			}

		</script>

	</body>
</html>
